# Maze Game

Maze Game — это учебная 2D‑игра «Лабиринт», написанная на языке **C** с использованием библиотеки [**Raylib**](https://www.raylib.com/).
Проект демонстрирует полный цикл разработки небольшой игры: от описания типов и конфигурации до реализации логики, 
алгоритмов поиска пути и пользовательского интерфейса.

Основная цель проекта — показать умение структурировать код, работать с игровым циклом, алгоритмами и простым UI на низком уровне.

## Скриншоты

<img width="941" height="529" alt="изображение" src="https://github.com/user-attachments/assets/2aa76ddb-394a-4d1c-a85e-89daa57b61c6" />

<img width="931" height="527" alt="изображение" src="https://github.com/user-attachments/assets/84ae8d47-b285-485e-a835-a1355dd26084" />

## Основные возможности
* Отрисовка лабиринта в окне Raylib и перемещение игрока по клеткам.
* Обработка пользовательского ввода с клавиатуры и обновление состояния игры в рамках игрового цикла.
* Встроенные структуры данных для описания лабиринта, сущностей и состояний игры.
* Реализация поиска кратчайшего пути в лабиринте и подсказка направления следующего шага.
* Пользовательский интерфейс: отрисовка текста, панели состояния, стрелки‑подсказки и других элементов.

## Структура проекта
```
Maze/
    logic/
        game.c
        game.h
        maze.c
        maze.h
        pathfinding.c
        pathfinding.h
    settings/
        types.h
        config.h
    ui/
        font_dejavu.h
        icon.ico
        icon.rc
        icon.res
        icon_ico.h
        ui.c
        ui.h
    all.c
    main.c
```

`logic/game.c` — управление состоянием игры и обработка ввода.

`logic/maze.c` — работа с лабиринтом: генерация карты, столкновений, расположение стартовой точки и выхода.

`logic/pathfinding.c` — алгоритм поиска пути (BFS) и функции расчета оптимального направления следующего шага.

`settings/types.h` — модель данных игры: состояния, координаты, лабиринт, игрок.

`settings/config.h` — константы и настройки (размеры карты, окна, и клеток).

`ui/ui.c и ресурсы в ui/` — отрисовка UI, встроенный шрифт, иконка игры.

`main.c` — точка входа, инициализация Raylib, создание игры, главный цикл и завершение.

`all.c` — вспомогательный файл для сборки всех модулей единым translation unit.

## Модель данных (types.h)

Вся ключевая модель игры собрана в заголовке `types.h`, что упрощает сопровождение и повторное использование кода.
Вот что включает в себя заголовок `types.h`:
### GameState
Перечисление состояний игры:

`GS_MENU` — главное меню;

`GS_PLAY` — активный процесс игры;

`GS_WIN` — состояние победы;

`GS_EXIT` — сигнал на выход из игры.

Позволяет централизованно управлять переходами между экранами и логикой.

### P2
Структура целочисленной точки/вектора на сетке:

`typedef struct { int x, y; } P2;`

Применяется как для хранения позиций (координаты клетки лабиринта), так и для представления направления движения (вектор шага).
Используется вместо `float Vector2` из Raylib, так как для работы с клетками удобнее оперировать целочисленными координатами.

### Maze
Описывает лабиринт:
```
typedef struct {
    int w, h;                    // размеры лабиринта в клетках
    char grid[MAP_H][MAP_W];     // карта лабиринта в виде двумерного массива символов
    P2 start, exit;              // позиция стартовой точки и выхода
} Maze;
```
- `w`, `h` — логические размеры лабиринта.  
- `grid` — двумерный массив символов с описанием карты:  
  - `'#'` — стена,  
  - `'.'` — свободная клетка,  
  - `'S'` — стартовая позиция игрока,  
  - `'E'` — выход.
- `start`, `exit` — заранее вычисленные координаты старта и выхода, чтобы не искать их каждый раз в массиве.
На основе этой структуры работает и отрисовка, и столкновения, и алгоритмы поиска пути.

### Player
Описывает состояние игрока:
```
    typedef struct {
        P2 pos;      // текущая позиция на карте
        P2 nextDir;  // направление следующего шага (подсказка)
    } Player;
```

`pos` — логическая позиция в сетке лабиринта (координаты клетки), которую графика затем переводит в пиксели.

`nextDir` — вектор направления следующего шага, вычисляемый алгоритмом поиска пути (например, `{1,0}`, `{0,-1}` и т.п.).

Это поле используется для отображения стрелки‑подсказки оптимального хода в интерфейсе.

## Используемые алгоритмы (pathfinding.c)

В модуле pathfinding.c реализован алгоритм поиска кратчайшего пути по сетке лабиринта и функция для перевода вектора направления в текст.

Поиск пути: NextStepBFS
```
bool NextStepBFS(const Maze* m, P2 from, P2 to, P2* outDir);
```
- Используется алгоритм **Breadth‑First Search (BFS)** по сетке `grid` размера `MAP_W * MAP_H`. 
- Внутри функции поддерживаются:  
  - очередь клеток (`qx`, `qy`) для обхода лабиринта в ширину;  
  - массивы `px`, `py` — «родители» клетки, позволяющие восстановить путь от финиша к старту;  
  - массив `vis` для отметки посещённых клеток.
Обход допускает переход только в свободные клетки (`'.'`), игнорируя стены и всё, что не является проходимым.
После завершения BFS путь восстанавливается от точки `to` (выход) обратно к `from` (позиция игрока), по цепочке родителей.
Функция возвращает в `outDir` направление **первого шага** оптимального пути от `from` к `to` в виде вектора `P2` и `true`, если путь найден.
Если путь отсутствует (выход недостижим), функция возвращает `false` и не меняет `outDir`.

На уровне геймплея это используется для подсказки игроку: «куда сделать следующий шаг, если идти по кратчайшему пути к выходу» — это направление затем выводится в интерфейсе.

Текстовое представление направления: **DirToText**
```
    const char* DirToText(P2 d);
```  
Преобразует вектор направления `P2` в читаемую строку: `"Right"`, `"Left"`, `"Up"`, `"Down"` или `"None"`.
Используется в UI для отображения подсказки следующего хода на боковой панели.

В совокупности `NextStepBFS + DirToText` образуют завершённый модуль навигации по лабиринту, который можно переносить и в другие проекты.

## Игровая логика и архитектура
Главный цикл реализован в `main.c` с использованием классической схемы Raylib: обработка ввода → обновление логики → отрисовка.

Логика игры `(game.c)` опирается на чётко описанные структуры (GameState, Maze, Player) и отделена от UI `(ui.c)`.

Конфигурация `(config.h)` и модель данных `(types.h)` выделены в отдельный слой settings/, что облегчает поддержку игры.

## Сборка и запуск

Для сборки проекта используется библиотека Raylib и заранее подготовленная конфигурация окружения на Windows. 
Ниже описан рекомендуемый сценарий сборки, ориентированный на использование комплекта «Notepad++ for raylib», входящего в дистрибутив библиотеки.​

#### Установка raylib
- Скачайте актуальную версию raylib для Windows [с официального сайта](https://www.raylib.com/) и распакуйте архив в удобную директорию.
- Убедитесь, что используется комплект с преднастроенной интеграцией Notepad++ и скриптами сборки (входит в состав некоторых бинарных пакетов raylib для Windows).

### Открытие проекта
- Запустите Notepad++, поставляемый вместе с raylib.
- Откройте файл all.c из корневой директории проекта Maze (он подключает все необходимые модули и служит единым входом для компиляции).

### Сборка
В комплекте «Notepad++ for raylib» уже настроен скрипт сборки, привязанный к горячей клавише F6 (Run / NPPExec), который вызывает компилятор с корректными флагами и путями к библиотеке raylib.
Для сборки достаточно нажать F6 и запустить готовый скрипт; в результате в каталоге проекта будет создан исполняемый файл all.exe (или другое имя, указанное в скрипте).

### Запуск
После успешной компиляции игру можно запустить напрямую, дважды щёлкнув по all.exe в проводнике либо вызвав его из командной строки:
```
bash
all.exe
```
Приложение собирается как самодостаточный `.exe`, статически или динамически линкующийся с необходимыми компонентами raylib согласно настройкам скрипта. 
Собранный `.exe` можно переносить на другие Windows‑системы без дополнительной установки raylib, при условии что все зависимости учтены на этапе линковки.

## Возможные направления развития
* Добавление новых алгоритмов поиска пути (A*, визуализация работы BFS по шагам на экране).
* Расширение структуры Player (счётчик шагов, время, статистика) и сохранение результатов в файл или базу.
* Перенос архитектурных идей (состояния, модель данных, алгоритмы) в другие проекты.
