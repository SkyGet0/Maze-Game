# Maze Game

Maze Game — это учебная 2D‑игра «Лабиринт», написанная на языке **C** с использованием библиотеки **Raylib**.
Проект демонстрирует полный цикл разработки небольшой игры: от описания типов и конфигурации до реализации логики, 
алгоритмов поиска пути и пользовательского интерфейса.

Основная цель проекта — показать умение структурировать код, работать с игровой петлёй, алгоритмами и простым UI на низком уровне.

## Скриншоты


## Основные возможности
* Отрисовка лабиринта в окне Raylib и перемещение игрока по клеткам.
* Обработка пользовательского ввода с клавиатуры и обновление состояния игры в рамках игрового цикла.
* Встроенные структуры данных для описания лабиринта, сущностей и состояний игры.
* Реализация поиска кратчайшего пути в лабиринте (BFS) и подсказка направления следующего шага.
* Пользовательский интерфейс: отрисовка текста, панели состояния, стрелки‑подсказки и других элементов.

## Структура проекта
```
Maze/
    logic/
        game.c
        game.h
        maze.c
        maze.h
        pathfinding.c
        pathfinding.h
    settings/
        types.h
        config.h
    ui/
        font_dejavu.h
        icon.ico
        icon.rc
        icon.res
        icon_ico.h
        ui.c
        ui.h
    all.c
    main.c
```

logic/game.c — управление состоянием игры (создание, обновление, обработка ввода).
logic/maze.c — работа с лабиринтом: карта, столкновения, старт/выход.
logic/pathfinding.c — алгоритм поиска пути (BFS) и функции для выдачи оптимального направления следующего шага.

settings/types.h — модель данных игры: состояния, координаты, лабиринт, игрок.
settings/config.h — константы и настройки (размеры карты, окна и прочее).

ui/ui.c и ресурсы в ui/ — отрисовка UI, встроенный шрифт, иконка окна.

main.c — точка входа, инициализация Raylib, создание игры, главный цикл и завершение.
all.c — вспомогательный файл для сборки всех модулей единым translation unit.

## Модель данных (types.h)

Вся ключевая модель игры собрана в заголовке types.h, что упрощает сопровождение и повторное использование кода.
* GameState *
Перечисление состояний игры:
    GS_MENU — главное меню;
    GS_PLAY — активный процесс игры;
    GS_WIN — состояние победы;
    GS_EXIT — сигнал на выход из игры.
Это позволяет централизованно управлять переходами между экранами и логикой.

* P2
Структура целочисленной точки/вектора на сетке:
typedef struct { int x, y; } P2;
Используется вместо Vector2 из Raylib, так как для работы с тайлами удобнее оперировать целочисленными координатами.
Применяется как для хранения позиций (координаты клетки лабиринта), так и для представления направления движения (вектор шага).

* Maze
Описывает лабиринт:
```
typedef struct {
    int w, h;                    // размеры лабиринта в клетках
    char grid[MAP_H][MAP_W];     // карта уровня
    P2 start, exit;              // старт и выход
} Maze;
```
- `w`, `h` — логические размеры лабиринта.  
- `grid` — двумерный массив символов с описанием карты:  
  - `'#'` — стена,  
  - `'.'` — свободная клетка,  
  - `'S'` — стартовая позиция игрока,  
  - `'E'` — выход.[file:38]  
- `start`, `exit` — заранее вычисленные координаты старта и выхода, чтобы не искать их каждый раз в массиве.
На основе этой структуры работает и отрисовка, и столкновения, и алгоритмы поиска пути.

* Player
Описывает состояние игрока:
```
    typedef struct {
        P2 pos;      // текущая позиция на карте
        P2 nextDir;  // направление следующего шага (подсказка)
    } Player;
```  
- `pos` — логическая позиция в сетке лабиринта (координаты клетки), которую графика затем переводит в пиксели.
- `nextDir` — вектор направления следующего шага, вычисляемый алгоритмом поиска пути (например, `{1,0}`, `{0,-1}` и т.п.).
Это поле используется для отображения стрелки‑подсказки оптимального хода в интерфейсе.

## Используемые алгоритмы (pathfinding.c)

В модуле pathfinding.c реализован алгоритм поиска кратчайшего пути по сетке лабиринта и сервисная функция для перевода вектора направления в текст.

Поиск пути: NextStepBFS
```
bool NextStepBFS(const Maze* m, P2 from, P2 to, P2* outDir);
```
- Используется алгоритм **Breadth‑First Search (BFS)** по сетке `grid` размера `MAP_W * MAP_H`. 
- Внутри функции поддерживаются:  
  - очередь клеток (`qx`, `qy`) для обхода лабиринта в ширину;  
  - массивы `px`, `py` — «родители» клетки, позволяющие восстановить путь от финиша к старту;  
  - массив `vis` для отметки посещённых клеток.
- Обход допускает переход только в свободные клетки (`'.'`), игнорируя стены и всё, что не является проходимым.
- После завершения BFS путь восстанавливается от точки `to` (выход) обратно к `from` (позиция игрока), по цепочке родителей.
- Функция возвращает в `outDir` направление **первого шага** оптимального пути от `from` к `to` в виде вектора `P2` и `true`, если путь найден.
- Если путь отсутствует (выход недостижим), функция возвращает `false` и не меняет `outDir`.

На уровне геймплея это используется для подсказки игроку: «куда сделать следующий шаг, если идти по кратчайшему пути к выходу» — это направление затем выводится в интерфейсе.

Текстовое представление направления: DirToText
```
    const char* DirToText(P2 d);
```  
    - Преобразует вектор направления `P2` в человекочитаемую строку: `"Right"`, `"Left"`, `"Up"`, `"Down"` или `"None"`.
    - Используется в UI для отображения подсказки следующего хода (например, на боковой панели или в статусной строке).

В совокупности NextStepBFS + DirToText образуют завершённый мини‑модуль навигации по лабиринту, который можно переносить и в другие проекты как пример реализации BFS и работы с дискретной картой.

## Игровая логика и архитектура
Главный цикл реализован в main.c с использованием классической схемы Raylib: обработка ввода → обновление логики → отрисовка.
Логика игры (game.c) опирается на чётко описанные структуры (GameState, Maze, Player) и отделена от UI (ui.c).
Конфигурация (config.h) и модель данных (types.h) выделены в отдельный слой settings/, что облегчает поддержку и перенос проекта.

## Сборка и запуск
Для сборки, запуска и поддержки игры, нужно скачать библиотеку raylib из официального источника.
Лучше всего использовать "NotePad++ for raylib", поставляемый вместе с библиотекой при скачивании - там уже настроены все скрипты.
Нужно всего лишь открыть файл all.c и скомпилировать его через F6.
Собранная игра будет выглядеть как файл all.exe, который можно спокойно распространять на другие Windows системы.
Игра собирается как самодостаточный .exe, поэтому для её запуска на другой системе, наличие raylib не обязательно.

## Возможные направления развития
* Добавление новых алгоритмов поиска пути (A*, визуализация работы BFS по шагам на экране).
* Расширение структуры Player (счётчик шагов, время, статистика) и сохранение результатов в файл или базу.
* Генерация лабиринтов (не только статическая карта) и динамическая пересборка Maze.
* Перенос архитектурных идей (состояния, модель данных, алгоритмы) в C#/.NET‑проекты (консольные утилиты, веб‑сервисы, игры).
