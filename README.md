# Maze Game

Maze Game — это учебная 2D‑игра «Лабиринт», написанная на языке **C** с использованием библиотеки [**Raylib**](https://www.raylib.com/).
Проект демонстрирует полный цикл разработки небольшой игры: от описания типов и конфигурации до реализации логики, 
алгоритмов поиска пути и пользовательского интерфейса.

Основная цель проекта — показать умение структурировать код, работать с игровым циклом, алгоритмами и простым UI на низком уровне.

## Скриншоты

<img width="941" height="529" alt="изображение" src="https://github.com/user-attachments/assets/2aa76ddb-394a-4d1c-a85e-89daa57b61c6" />

<img width="931" height="527" alt="изображение" src="https://github.com/user-attachments/assets/84ae8d47-b285-485e-a835-a1355dd26084" />

## Основные возможности
* Отрисовка лабиринта в окне Raylib и перемещение игрока по клеткам.
* Обработка пользовательского ввода с клавиатуры и обновление состояния игры в рамках игрового цикла.
* Встроенные структуры данных для описания лабиринта, сущностей и состояний игры.
* Реализация поиска кратчайшего пути в лабиринте и подсказка направления следующего шага.
* Пользовательский интерфейс: отрисовка текста, панели состояния, стрелки‑подсказки и других элементов.

## Структура проекта
```
Maze/
    logic/
        game.c
        game.h
        maze.c
        maze.h
        pathfinding.c
        pathfinding.h
    settings/
        types.h
        config.h
    ui/
        font_dejavu.h
        icon.ico
        icon.rc
        icon.res
        icon_ico.h
        ui.c
        ui.h
    all.c
    main.c
```

`logic/game.c` — управление состоянием игры и обработка ввода.

`logic/maze.c` — работа с лабиринтом: генерация карты, столкновений, расположение стартовой точки и выхода.

`logic/pathfinding.c` — алгоритм поиска пути (BFS) и функции расчета оптимального направления следующего шага.

`settings/types.h` — модель данных игры: состояния, координаты, лабиринт, игрок.

`settings/config.h` — константы и настройки (размеры карты, окна, и клеток).

`ui/ui.c и ресурсы в ui/` — отрисовка UI, встроенный шрифт, иконка игры.

`main.c` — точка входа, инициализация Raylib, создание игры, главный цикл и завершение.

`all.c` — вспомогательный файл для сборки всех модулей единым translation unit.

## Модель данных (types.h)

Вся ключевая модель игры собрана в заголовке `types.h`, что упрощает сопровождение и повторное использование кода.

Содержимое `types.h`:
#### GameState
Перечисление состояний игры:

`GS_MENU` — главное меню;

`GS_PLAY` — активный процесс игры;

`GS_WIN` — состояние победы;

`GS_EXIT` — сигнал на выход из игры.

Позволяет централизованно управлять переходами между экранами и логикой.

#### P2
Структура целочисленной точки/вектора на сетке:

`typedef struct { int x, y; } P2;`

Применяется как для хранения позиций (координаты клетки лабиринта), так и для представления направления движения (вектор шага).
Используется вместо `float Vector2` из Raylib, так как для работы с клетками удобнее оперировать целочисленными координатами.

#### Maze
Описывает лабиринт:
```
typedef struct {
    int w, h;                    // размеры лабиринта в клетках
    char grid[MAP_H][MAP_W];     // карта лабиринта в виде двумерного массива символов
    P2 start, exit;              // позиция стартовой точки и выхода
} Maze;
```
- `w`, `h` — логические размеры лабиринта.  
- `grid` — двумерный массив символов с описанием карты:  
  - `'#'` — стена,  
  - `'.'` — свободная клетка,  
  - `'S'` — стартовая позиция игрока,  
  - `'E'` — выход.
- `start`, `exit` — заранее вычисленные координаты старта и выхода, чтобы не искать их каждый раз в массиве.
На основе этой структуры работает и отрисовка, и столкновения, и алгоритмы поиска пути.

#### Player
Описывает состояние игрока:
```
    typedef struct {
        P2 pos;      // текущая позиция на карте
        P2 nextDir;  // направление следующего шага (подсказка)
    } Player;
```

`pos` — логическая позиция в сетке лабиринта (координаты клетки), которую графика затем переводит в пиксели.

`nextDir` — вектор направления следующего шага, вычисляемый алгоритмом поиска пути (например, `{1,0}`, `{0,-1}` и т.п.).

## Используемые алгоритмы (pathfinding.c и maze.c)

В проекте реализованы два ключевых алгоритма для работы с лабиринтом.
#### 1. Генерация лабиринта: `GenerateMaze` (DFS backtracker)
```
void GenerateMaze(Maze* m, unsigned seed);
```
**Алгоритм:** Рекурсивный **DFS backtracker** (идеальный лабиринт):

1. **Инициализация:** Заполнение всей сетки стенами (`FillWalls`), создание стартовой точки в позиции `{1,1}`.
2. **Рекурсивный обход (`Carve`):**
   - Из текущей клетки пробуем 4 направления: `{2,0}`, `{-2,0}`, `{0,2}`, `{0,-2}` (чтобы пропускать одну клетку между соседями).
   - **Рандомизация порядка направлений** через `GetRandomValue` (shuffle).
   - Для каждого непосещённого направления (стена `'#'`):
     - Вырезаем проход в промежуточной клетке и соседней: `m->grid[wy][wx]='.'; m->grid[ny][nx]='.'`
     - Рекурсивно продолжаем из соседней клетки.
3. **Завершение:** Рамка из стен по периметру, автоматический поиск ближайших проходов для `start` (слева) и `exit` (справа).

**Результат:** Гарантированно связный лабиринт с единственным решением (идеальный maze), генерируемый с каждым запуском по‑новому.

### 2. Поиск пути: `NextStepBFS` (Breadth-First Search)

```
bool NextStepBFS(const Maze* m, P2 from, P2 to, P2* outDir);
```
**Алгоритм BFS** по сетке `MAP_W * MAP_H` для нахождения кратчайшего пути от позиции игрока к выходу:

1. **Очередь обхода:** `qx[]`, `qy[]` — координаты клеток для BFS.
2. **Отслеживание пути:** `px[MAP_H][MAP_W]`, `py[MAP_H][MAP_W]` — «родитель» каждой клетки для восстановления пути.
3. **Посещённые:** `vis[MAP_H][MAP_W]` — массив для исключения повторного обхода.
4. **Правила обхода:** Только свободные клетки `'.'`, игнорируются стены.
5. **Восстановление пути:** После достижения выхода идем по цепочке родителей от `to` к `from`, определяем первый шаг и возвращаем его как вектор `P2` в `outDir`.

**Результат:** Направление оптимального следующего шага для игрока (используется как подсказка в UI).

### 3. Текстовое представление направления: `DirToText`
```
const char* DirToText(P2 d);
```
Преобразует вектор направления в читаемый текст: `"Right"`, `"Left"`, `"Up"`, `"Down"`, `"None"` для отображения в боковой панели.

**DFS + BFS в одном проекте** демонстрируют полный цикл работы с лабиринтом: **генерация** → **поиск пути**. Это классический пример алгоритмов на графах, применимый и в геймдеве, и в backend‑задачах (поиск маршрутов, планирование, навигация).

## Игровая логика и архитектура
Главный цикл реализован в `main.c` с использованием классической схемы Raylib: обработка ввода → обновление логики → отрисовка.

Логика игры `(game.c)` опирается на чётко описанные структуры (GameState, Maze, Player) и отделена от UI `(ui.c)`.

Конфигурация `(config.h)` и модель данных `(types.h)` выделены в отдельный слой settings/, что облегчает поддержку игры.

## Сборка и запуск

Для сборки проекта используется библиотека Raylib и заранее подготовленная конфигурация окружения на Windows. 
Ниже описан рекомендуемый сценарий сборки, ориентированный на использование комплекта «Notepad++ for raylib», входящего в дистрибутив библиотеки.​

#### Установка Raylib
- Скачайте актуальную версию Raylib для Windows [с официального сайта](https://www.raylib.com/) и распакуйте архив в удобную директорию.
- Убедитесь, что используется комплект с преднастроенной интеграцией Notepad++ и скриптами сборки (входит в состав некоторых бинарных пакетов raylib для Windows).

#### Открытие проекта
- Запустите Notepad++, поставляемый вместе с raylib.
- Откройте файл all.c из корневой директории проекта Maze (он подключает все необходимые модули и служит единым входом для компиляции).

#### Сборка проекта
В комплекте «Notepad++ for raylib» уже настроен скрипт сборки, привязанный к горячей клавише F6 (Run / NPPExec), который вызывает компилятор с корректными флагами и путями к библиотеке raylib.
Для сборки достаточно нажать F6 и запустить готовый скрипт; в результате в каталоге проекта будет создан исполняемый файл all.exe (или другое имя, указанное в скрипте).

#### Запуск игры
После успешной компиляции игру можно запустить напрямую, дважды щёлкнув по all.exe в проводнике либо вызвав его из командной строки:
```
bash
all.exe
```
Игра собирается как самодостаточный `.exe`, статически (или динамически) линкующийся с необходимыми компонентами Raylib согласно настройкам скрипта. 
Собранный `.exe` можно переносить на другие Windows‑системы без дополнительной установки Raylib, при условии что все зависимости учтены на этапе линковки.

## Возможные направления развития
* Добавление новых алгоритмов поиска пути (A*, визуализация работы BFS по шагам на экране).
* Расширение структуры Player (счётчик шагов, время, статистика) и сохранение результатов в файл или базу.
* Перенос архитектурных идей (состояния, модель данных, алгоритмы) в другие проекты.
